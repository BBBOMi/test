3> 고급문법

1. 객체 배열
-> 부모 클래스 타입의 변수가 자식 클래스 타입의 변수를 가리키는 것은 OK
	but, 자식 클래스 타입의 변수가 부모 클래스 타입의 변수를 가리키는 것은 안됨
	=> 클래스 상속할 때의 화살표 방향 반대로 가능하다고 알아두자.
	
	Parent p;         
	Child c;         
	
	p = new Parent("부모1");         
	c = new Child("아들1", 18);         
	p = new Child("아들2", 16);         
	
	//c = new Parent();         
	//c = p;         => 주석 부분은 불가능
	
	=> Child 타입의 참조 변수에 Parent 객체를 대입하는 것은 컴파일 오류가 발생한다.
	=> 참조 변수 p가 가르키는 것은 줄40에서 생성된 Child 객체이다.  
		이 Child 객체에 대한 참조를, Child 타입의 참조 변수 c에 대입하는 것인데도 컴파일 오류가 발생한다.(p4.)

-> class Child extends Parent {     
	int age;     
		
	Child(String name, int age) {         
		super(name); // 부모 클래스 생성자 호출     => 항상 호출, 명시 하지 않아도 호출 됨    
		this.age = age;     
	}
	
	부모 클래스 생성자 호출의 기본형은 기본 생성자임(매개변수가 없는)
	매개 변수가 있는 생성자를 호출하고 싶을 때엔 위의 코드처럼 하면 된다(매개변수: name)
	
-> 참조만 포함관계, 객체는 모두 독립적

-> p5. 배열 클래스 코드의 equals메소드 결과는 false
	=> 메소드 재정의를 하지 않았기 때문
	

2. 기본 자료형 클래스

3. static member
-> private static int instanceCount = 0;      // static member 변수
   private int numerator;     
   private int denominator; // 인스턴스 멤버 변수
   
-> static member 변수는 Data Segment 부분에 생성됨(Data Segment는 처음부터 생성)
   instance member 변수는 Stack Segment 부분에 생성됨(Stack Segment는 메소드 생성될 때 생성 return시 제거)
   (Heap Segment 부분은 new할 때 생성되었다 garbage collection에 의해 제거)
   


